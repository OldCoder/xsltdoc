<?xml version="1.0" encoding="UTF-8"?>

<!-- ============================================================= -->
<!-- File:            API_Reference.xml                            -->
<!-- Purpose:         Brick Engine C API Reference, XML version    -->
<!-- Original author: hat0                                         -->
<!-- License:         MIT/X                                        -->
<!-- Revision:        110108                                       -->
<!-- ============================================================= -->

<!-- <![CDATA[
To convert this XML documentation file to DokuWiki format, use a Linux
command of the form:

xsltproc xmldoc2dokuwiki.xsl API_Reference.xml > \
                             API_Reference.dokuwiki

To convert this XML documentation  file  to  HTML  format, use a Linux
command of the form:

xsltproc xmldoc2html.xsl     API_Reference.xml > \
                             API_Reference.html

If you use other XLST processors, changes may be required. Additional-
ly,  if you edit this file,  use a text editor  that  preserves white-
space.
]]> -->

<!-- ============================================================= -->

<section title="C API Reference">

<desc>Welcome to the quick reference guide for the Brick Engine, v5.2.
This document covers the C API.</desc>

<section title="Basic Engine Operation">

<section title="Starting and stopping the Brick Engine">

<desc>Just about everything you'll do with the Brick Engine requires
that you initialize it first. After you're done, too, you may
want to free up any resources held by the engine.</desc>

<function name="init_brick()">
<cproto>void init_brick();</cproto>
<desc>Prepares the engine internal data structures and activates the
hardware.</desc>
</function>

<function name="quit_brick()">
<cproto>void quit_brick();</cproto>
<desc>Shuts down the engine, closes the graphics display, halts all
sounds, and frees up any resources used by the engine.</desc>
</function>

</section>
<section title="Graphics">

<desc>The graphics display may be started and stopped at any time
(for example, to change from windowed to full-screen mode, or to
change the display resolution), without interfering with the
rest of the engine. These are the routines to activate and
deactivate the graphics display.</desc>

<function name="graphics_open()">
<cproto>int graphics_open(int mode, int w, int h, int fs, int zf);</cproto>
<desc>Opens the graphics display. The <namedvar>mode</namedvar> value
is one of the following: <namedvar>GRAPHICS_SDL</namedvar>
(standard SDL display) or <namedvar>GRAPHICS_ACCEL</namedvar>
(OpenGL-accelerated blit to screen). The graphics display size
is given in <namedvar>w</namedvar> and <namedvar>h</namedvar>.</desc>

<desc><note>Note: There is a compile-time maximum width and
height, which defaults to 640x480.</note></desc>

<desc>Full-screen mode is controlled by the boolean
<namedvar>fs</namedvar> flag. In the accelerated graphics output
mode, the zoom factor <namedvar>zf</namedvar> determines the
amount by which the display is scaled. <note>Note that a
zoom factor of either 0 or 1 has no effect on the output
display.</note></desc>

<desc>Returns 0 on success, or an error code on failure.</desc>
</function>

<function name="graphics_close()">
<cproto>void graphics_close();</cproto>
<desc>Closes the active graphics display.</desc>
</function>

<function name="graphics_info()">
<cproto>int graphics_info(int *w, int *h);</cproto>
<desc>Returns the active graphics mode, and stores the current display
resolution in <namedvar>w</namedvar> and <namedvar>h</namedvar>.</desc>
</function>

</section>
<section title="Audio">

<desc>Audio output may be activated or deactivated at any time. These
routines let you do that.</desc>
<function name="audio_open()">
<cproto>int audio_open(int mode, char *file);</cproto>
<desc>Opens the audio output. <namedvar>mode</namedvar> is one of the
following:</desc>
<desc>AUDIO_SPEAKER (speaker output).</desc>
</function>

<function name="audio_close()">
<cproto>void audio_close();</cproto>
<desc>Closes the active audio output.</desc>
</function>

</section>
<section title="Input">

<desc>These are functions used to configure and read user input from
keyboard, joystick, and mouse. The joystick is the primary type
of input device recognized by the Brick Engine, and the engine
supports up to eight joysticks at a time. You don't need any
actual joysticks to play, because the engine will map all
keyboard input onto one of eight "virtual joysticks": each
keypress is turned into an axis, hat, or button motion on one of
the eight joysticks, and this keyboard-input mapping can be
altered at any time. If you've got actual hardware joysticks
plugged in, the inputs provided by these joysticks (axes, hats,
and buttons) can be read directly.</desc>

<function name="io_fetch()">
<cproto>int io_fetch(int input, input *io);</cproto>
<desc>Retrieves the status of the given input into
<namedvar>io</namedvar>.</desc>

<desc>There are eight inputs from which movement and actions can be
requested, numbered 0 through 7. Keys can be assigned to any
action (axis, hat, or button) on any input. If joysticks are
plugged in, they are assigned to the inputs starting at
<namedvar>0</namedvar>.</desc>

<desc>Axes have a range from -127 to 127. Key presses will set the
axis to the ends of this range, while an analog joystick input
may return any value within this range. Up to eight axes are
read, either from joystick or from the assigned keys.</desc>

<desc>Usually, the first two axes will represent horizontal and
vertical motion, either from the keyboard or the joystick.
Joysticks with more than one analog stick will use additional
axes to represent the movement on the additional sticks. By
default, the arrow keys are mapped onto axes 0 and 1 on input 0.</desc>

<desc>Hats represent the four-way directional inputs present on some
joysticks. Hat values range from -1 to 1 and are returned as
pairs of horizontal and vertical results. Note that a joypad-
style controller with just one directional input probably
returns its results as a pair of axes rather than a hat. By
default, the keys <namedvar>wasd</namedvar> are mapped onto hat
0 of input 0.</desc>

<desc>Button presses return either 0 or 1. By default, the keys
<namedvar>left ctrl</namedvar>, <namedvar>left alt</namedvar>,
<namedvar>z</namedvar>, and <namedvar>x</namedvar> are assigned
to button presses 0 through 3 on input 0.</desc>

<desc>There are eight axes, four hats, and twenty buttons available on
each input. If a physical joystick has more axes, hats, or
buttons than this, the excess will be ignored.</desc>

<desc>The keys <namedvar>space</namedvar>, <namedvar>tab</namedvar>,
<namedvar>enter</namedvar> or <namedvar>return</namedvar> (as
<namedvar>select</namedvar>), <namedvar>pause</namedvar>, and
<namedvar>escape</namedvar> are always included in the results.</desc>
</function>

<function name="io_mouse()">
<cproto>int io_mouse(int input, mouse *);</cproto>
<desc>Reads the mouse motions on the specified mouse input.</desc>
</function>

<function name="io_grab()">
<cproto>void io_grab(int flag);</cproto>
<desc>Grabs the keyboard and mouse input, preventing interference from
the window manager or operating system. <note>Warning: Be
sure that your game is thoroughly debugged before using this
routine!! If your game has an infinite loop and the input grab
is enabled, there will be no way for the player to exit
gracefully.</note></desc>
</function>

<function name="io_has_quit()">
<cproto>int io_has_quit();</cproto>
<desc>Returns whether or not a quit signal has been received by the
game, e.g. clicking the close button of the game window.</desc>
</function>

<function name="io_wait()">
<cproto>int io_wait(int delay);</cproto>
<desc>Waits until all input buffers are cleared, and then waits until
any activity on any of the inputs is received. If the
application-quit button is pressed, this immediately returns
ERR. The <namedvar>delay</namedvar> value indicates how many
times each second the inputs will be checked for activity, so
that the processor use can be kept low.</desc>
</function>

<function name="io_assign()">
<cproto>void io_assign(int input, int type, ... );
void io_assign(int input, int type = IO_AXIS, int axis_no,
    int dir, int keycode);
void io_assign(int input, int type = IO_HAT, int hat_no,
    int dir, int keycode);
void io_assign(int input, int type = IO_BUTTON,
    int button_no, int keycode);</cproto>
<desc>Assigns a keycode to the action on the given input. The
combination of axis, hat, button number, and direction specifies
which joystick action will have a keyboard-mapping assigned. The
type must be one of <namedvar>IO_AXIS</namedvar>,
<namedvar>IO_HAT</namedvar>, <namedvar>IO_BUTTON</namedvar>. If
the action type is <namedvar>IO_AXIS</namedvar>, then only the
directions <namedvar>IO_LEFT</namedvar> and
<namedvar>IO_RIGHT</namedvar> are permitted. If the action type
is <namedvar>IO_HAT</namedvar>, then the directions
<namedvar>IO_LEFT</namedvar>, <namedvar>IO_UP</namedvar>,
<namedvar>IO_DOWN</namedvar>, and <namedvar>IO_RIGHT</namedvar>
are permitted. Note that if the action type is
<namedvar>IO_BUTTON</namedvar>, then the direction argument is
omitted.</desc>
</function>

<function name="io_read_key()">
<cproto>int io_read_key()</cproto>
<desc>Halts until a single keypress can be read and a keycode
returned.</desc>

<desc>This is not useful for general-purpose input, but is intended
only to let the programmer determine keycodes interactively, for
use with <namedvar>io_assign()</namedvar>.</desc>
</function>

</section>
</section>
<section title="The Graphics Subsystem">

<desc>There are two parts of the Brick Engine graphics subsystem that
deal with system-wide graphics configuration: render settings
and font handling. Everything else (for example, sprites,
strings, and tile-based maps) is addressed later on.</desc>

<section title="Rendering">

<desc>These are the routines used to set system-wide rendering
options.</desc>

<function name="render_set_bg_fill()">
<cproto>void render_set_bg_fill(int fill);</cproto>
<desc>Enable or disable the solid-color background fill.</desc>
</function>

<function name="render_set_bg_color()">
<cproto>void render_set_bg_color(char r, char g, char b);</cproto>
<desc>Sets the background fill color to the given RGB values.</desc>
</function>

<function name="render_set_overdraw()">
<cproto>void render_set_overdraw(int w, int h);</cproto>
<desc>Sets the amount of overdraw applied to the internal render
canvas. This does not affect the displayed canvas size. Some
sprite frame types (e.g. the pixel-repositioning frame) may
depend on graphics data being drawn outside the screen borders
for proper composition of the display, and the overdraw
instructs the renderer to generate this extra data.</desc>
</function>

<function name="render_display()">
<cproto>void render_display();</cproto>
<desc>Renders and displays the current frame.</desc>
</function>

<function name="render_to_disk()">
<cproto>int render_to_disk(char *file);</cproto>
<desc>Renders the current frame to the so-named file.</desc>
</function>

</section>
<section title="Fonts">

<desc>The Brick Engine has a simple and lightweight font renderer
built in. Fonts are loaded into the engine as bitmaps, and
characters are fixed-width. One font, named
<namedvar>default</namedvar>, is built into the Brick Engine,
and additional fonts can be loaded at any time.</desc>

<function name="font_add()">
<cproto>void font_add(char *name, int w, int h, unsigned char *data,
    color *key);</cproto>
<desc>Adds a new font named <namedvar>name</namedvar>, with the bitmap
data stored in <namedvar>data</namedvar>. If
<namedvar>key</namedvar> is not null, it will be used as a
chroma key for the font display. The <namedvar>data</namedvar>
buffer is three-bytes-per-pixel RGB data, consisting of an image
of all characters in the font arranged in order. The dimensions
of each character are given in <namedvar>w</namedvar> and
<namedvar>h</namedvar>, and the font image must be 128
characters wide.</desc>
</function>

<function name="font_info()">
<cproto>int font_info(char *name, int *w, int *h);</cproto>
<desc>Retrieves the character dimensions of the named font. Returns 0
on success, or ERR if the font does not exist.</desc>
</function>

<function name="font_from_disk()">
<cproto>void font_from_disk(char *name, char *file, color *key);</cproto>
<desc>Adds a new font named <namedvar>name</namedvar> from the
compressed image file named <namedvar>file</namedvar>. If
<namedvar>key</namedvar> is not null, it will be used as a
chroma key for the font display. The font image is assumed to be
128 characters wide. <note>Note: This routine is only
available if the Brick Engine was built with SDL_image
support.</note></desc>
</function>

<function name="font_from_buffer()">
<cproto>void font_from_buffer(char *name, int len,
    unsigned char *data, color *key);</cproto>
<desc>Adds a new font named <namedvar>name</namedvar> from the
<namedvar>data</namedvar> buffer which contain a compressed
image file. If <namedvar>key</namedvar> is not null, it will be
used as a chroma key for the font display. The font image is
assumed to be 128 characters wide. <note>Note: This
routine is only available if the Brick Engine was built with
SDL_image support.</note></desc>
</function>

</section>
</section>
<section title="The Audio Subsystem">

<desc>Every game needs sound! The Brick Engine provides functionality
that makes it possible to handle both song and sound playback
with ease.</desc>

<section title="Sound playback">

<desc>These routines let you load sounds from different sources (from
a known sound file format stored on disk or in a memory buffer,
or as raw sound data), play them as needed, and stop them or
adjust the sound volume/panning in mid-play.</desc>

<function name="sound_load_from_disk()">
<cproto>sound *sound_load_from_disk(char *filename);</cproto>
<desc>Loads a sound from a file on disk. The list of supported file
formats can be found in the documentation for <link
target="http://www.libsdl.org/projects/SDL_mixer/"
name="SDL_mixer." /></desc>
</function>

<function name="sound_load_from_buffer()">
<cproto>sound *sound_load_from_buffer(int length, unsigned char *data);</cproto>
<desc>Loads a sound from the <namedvar>data</namedvar> buffer. The
buffer length is given in <namedvar>length</namedvar>. The list
of supported file formats can be found in the documentation for
<link target="http://www.libsdl.org/projects/SDL_mixer/"
name="SDL_mixer." /></desc>
</function>

<function name="sound_load_raw()">
<cproto>sound *sound_load_raw(int length, unsigned char *data);</cproto>
<desc>Creates a sound from the given data buffer. The data must match
the audio format set at compile time. By default, the audio
format is 8-bit unsigned data.</desc>
</function>

<function name="sound_play()">
<cproto>int sound_play(sound *sound, int volume);</cproto>
<desc>Plays the given sound. The volume may range from 0 to 128. This
returns the ID of the audio channel that is playing the sound,
so that the sound can be stopped or have its volume or panning
values adjusted.</desc>
</function>

<function name="sound_halt()">
<cproto>void sound_halt(int id);</cproto>
<desc>Stops the sound playing on the given channel. If
<namedvar>id</namedvar> is -1, halt all sounds.</desc>
</function>

<function name="sound_adjust_vol()">
<cproto>void sound_adjust_vol(int id, int volume);</cproto>
<desc>Sets the volume of the sound playing on the given channel ID.
The volume may range from 0 to 128. If <namedvar>id</namedvar>
is -1, sets the volume for all currently-playing sounds.</desc>
</function>

<function name="sound_adjust_pan()">
<cproto>void sound_adjust_an(int id, int panning);</cproto>
<desc>Sets the panning of the sound playing on the given channel ID.
The panning value ranges from 0 (left speaker only) to 254
(right speaker only), and is balanced at 127. If
<namedvar>id</namedvar> is -1, sets the panning for all
currently-playing sounds.</desc>
</function>

</section>
<section title="Song playback">

<desc>The song playback routines will let you start, stop, and
otherwise control the background music for your game.
<note>Note that because the Brick Engine relies on <link
target="http://www.libsdl.org/projects/SDL_mixer/"
name="SDL_mixer" /> for its music playback support, so the list
of supported file formats depends on how SDL_Mixer has built for
your system.</note></desc>

<function name="song_play_from_disk()">
<cproto>void song_play_from_disk(char *filename,
    int fade_in_delay);</cproto>
<desc>Loads and plays the named song from disk, with a fade-in delay
given in milliseconds.</desc>
</function>

<function name="song_play_from_buffer()">
<cproto>void song_play_from_buffer(int length, unsigned char *buffer,
    int fade_in_delay);</cproto>
<desc>Loads and plays the named song from a memory buffer of length
<namedvar>length</namedvar>, with a fade-in delay given in
milliseconds.</desc>
</function>

<function name="song_pause()">
<cproto>void song_pause();</cproto>
<desc>Pauses the currently-playing song.</desc>
</function>

<function name="song_resume()">
<cproto>void song_resume();</cproto>
<desc>Resumes the currently-paused song.</desc>
</function>

<function name="song_stop()">
<cproto>void song_stop(int fade_out_delay);</cproto>
<desc>Stops the currently-playing song with fade-out delay given in
milliseconds.</desc>
</function>

<function name="song_set_position()">
<cproto>void song_set_position(int pos);</cproto>
<desc>Sets the position of the currently-playing song.</desc>
</function>

<function name="song_adjust_vol()">
<cproto>void song_adjust_vol(int volume);</cproto>
<desc>Sets the music playback volume. The volume can range from 0 to
128.</desc>
</function>

</section>
</section>
<section title="Items and Lists">

<desc>These are the bread-and-butter routines in the Brick Engine, the
API calls you'll use again and again in developing your games,
so it's worth it to familiarize yourself with these.</desc>

<section title="Lists">

<desc>Lists are everywhere in computing, and the Brick Engine is no
different. The list implementation built into the engine is a
pretty simple doubly-linked list, and you'll most often use it
in two places: adding sprites and strings to the sprite- and
string- display lists, and getting back lists of sprites from
the introspection routines. (You may also find some more
sophisticated uses for the Brick Engine lists, though, e.g.
setting up some intricate collision-detection schemes where
you'll test certain groups of enemy sprites against certain
player projectiles.) These routines are what you'll use to
create and manipulate Brick Engine lists.</desc>

<function name="list_create()">
<cproto>list *list_create();</cproto>
<desc>Creates a new list.</desc>
</function>

<function name="list_empty()">
<cproto>void list_empty(list *list);</cproto>
<desc>Empties the given list. Note that this does not delete any of
the items in the list.</desc>
</function>

<function name="list_delete()">
<cproto>void list_delete(list *list);</cproto>
<desc>Deletes the given list. Note that this does not delete any of
the items in the list.</desc>
</function>

<function name="list_add()">
<cproto>void list_add(list *list, void *item);</cproto>
<desc>Adds the given item to the end of the list.</desc>
</function>

<function name="list_prepend()">
<cproto>void list_prepend(list *list, void *item);</cproto>
<desc>Adds the given item to the start of the list.</desc>
</function>

<function name="list_shift()">
<cproto>void *list_shift(list *list);</cproto>
<desc>Removes the first item from the head of the list and returns it.</desc>
</function>

<function name="list_pop()">
<cproto>void *list_pop(list *list);</cproto>
<desc>Removes the last item from the list and returns it.</desc>
</function>

<function name="list_remove()">
<cproto>void list_remove(list *list, void *item, int direction);</cproto>
<desc>Removes the given item from the list. The
<namedvar>direction</namedvar> flag can be set to LIST_HEAD,
LIST_TAIL, or LIST_ALL. If set to LIST_HEAD or LIST_TAIL, this
routine removes the first matching entry it finds from the
beginning or end of the list. If <namedvar>LIST_ALL</namedvar>
is given, then all matching items are removed from the list.</desc>
</function>

<function name="list_length()">
<cproto>int list_length(list *list);</cproto>
<desc>Returns a count of the number of items in the given list.</desc>
</function>

<function name="list_find()">
<cproto>int list_find(list *list, void *item);</cproto>
<desc>Determines whether the given item is in the list.</desc>
</function>

<function name="list_sort()">
<cproto>void list_sort(list *list, int(*)(void *, void *));</cproto>
<desc>Sorts the list using the provided comparison function.</desc>
</function>

<section title="List Iterator Macros">

<desc>There are now several macros provided in the Brick Engine header
file to provide basic list iteration capability.</desc>

<function name="iterator_start()">
<cproto>iterator_start(iterator i, list l);</cproto>
<desc>Initializes an iterator struct to point to the head of the given
list. You must call this before using any of the other iterator
macros.</desc>
</function>

<function name="iterator_next()">
<cproto>iterator_next(iterator i);</cproto>
<desc>Advances the iterator one step forward. If there are no more
list entries, then this does nothing.</desc>
</function>

<function name="iterator_data()">
<cproto>iterator_data(iterator i);</cproto>
<desc>Retrieves the item held in the current list position.</desc>
</function>

<function name="iterator_ct()">
<cproto>iterator_ct(iterator i);</cproto>
<desc>Gives the number of iterations through the list that have been
made in this iteration.</desc>
</function>

</section>
</section>
<section title="Frames">

<desc>A frame is a container for any sort of graphics data in the
Brick Engine. Whether you are working with simple pixel data,
color keyed data (i.e. one color treated as transparent), or one
of the various visual effects (e.g. convolution kernel,
desaturation, and so on), the data is always stored in a frame.
Some of the sprite and tile routines, such as
sprite_add_frame_data(), handle the process of creating and
loading the frame for you, but others, such as
sprite_add_subframe(), require that you create and prepare the
frame before passing it to the routine.</desc>

<desc>Frames can be sliced into subframes (good for cutting up sprite
sheets), and it's also possible to convert RGB frames into
almost any other frame type, e.g. to create a desaturated
version of a sprite, for use in some effect.</desc>

<desc>Last, if you've built the Brick Engine with the SDL_Image
dependency, you can load and unpack a variety of image types
directly into frames, either from disk or from a memory buffer.</desc>

<function name="frame_create()">
<cproto>frame *frame_create(int mode, int width, int height, void *data,
    void *auxiliary);</cproto>
<desc>Creates a new graphics frame using the given frame data.
<namedvar>mode</namedvar> is one of: FRAME_NONE (no display
data), FRAME_RGB (RGB data with an optional chroma-key),
FRAME_DISPL (pixel-displacement frame), FRAME_CONVO (convolution
kernel), FRAME_BR (brightness-adjusting frame), FRAME_CT
(contrast-adjusting frame), FRAME_LT (luminance-adjusting
frame), FRAME_SAT (saturation-adjusting frame), FRAME_LUT (RGB
lookup-table frame). The width and height are given in
<namedvar>width</namedvar> and <namedvar>height</namedvar>.</desc>

<desc>A frame type of FRAME_NONE takes no display data and produces no
output. The <namedvar>data</namedvar> and
<namedvar>auxiliary</namedvar> arguments are ignored. This isn't
very useful, except for situations where some unusual collision
detection is needed.</desc>

<desc>If the frame type is FRAME_RGB, the data is a buffer of RGB
pixels. An optional chroma key can be passed in as a
<namedvar>color</namedvar> in <namedvar>auxiliary</namedvar>.
The frame data will be drawn onto the render canvas.</desc>

<desc>If the type is FRAME_DISPL, the pixel data is an array of 16-bit
(big-endian) X/Y coordinate pairs. Each coordinate pair
represents an offset from the pixel in the frame to the location
in the underlying image data from which to retrieve the given
pixel. For example, pixel data consisting of only zeros has no
effect, while pixel data containing all pairs of -1, -1 will
create a frame that offsets the underlying image data up and to
the left by one pixel.</desc>

<desc>If the type is FRAME_CONVO, then the <namedvar>data</namedvar>
array is a pixel mask, in which each non-zero pixel applies the
specified convolution kernel to the underlying image data. The
convolution kernel definition is passed into
<namedvar>auxiliary</namedvar> as a
<namedvar>convolution</namedvar>.</desc>

<desc>If the type is FRAME_BR, the data is a buffer of RGB pixels. A
pixel component value of 64 is neutral and doesn't alter the
image brightness. Values less than 64 darken the image, and
values greater than 64 brighten the image.</desc>

<desc>If the type is FRAME_CT, the data is a buffer of unsigned char
values which adjust the contrast of the underlying image. A
pixel component value of 64 is neutral and leaves the image
contrast unaltered. Values less than 64 decrease the image
contrast to a neutral grey, and values greater than 64 increase
the contrast of the image.</desc>

<desc>If the type is FRAME_LT, the data is a buffer of RGB pixels. A
pixel component value of 128 is neutral and doesn't alter image
lightness. Values less than 128 darken the image toward black,
and values greater than 128 lighten the image toward white.</desc>

<desc>If the type is FRAME_SAT, the data is a buffer of unsigned char
values which adjust the saturation of the underlying image. A
pixel value of 128 leaves the image unchanged. A value of 64
desaturates the image, and values between 64 and 128 give
varying degrees of desaturation. Values less than 64 invert the
hue of the image data. Values greater than 128 increase the
saturation.</desc>

<desc>If the type is FRAME_LUT, the data is a buffer of unsigned chars
which act as a pixel mask. Each non-zero pixel causes the
underlying image data to be replaced according to that pixel's
value in the lookup table. The lookup table is passed into
<namedvar>auxiliary</namedvar> as a 256-element array of
<namedvar>color</namedvar> values.</desc>
</function>

<function name="frame_info()">
<cproto>int frame_info(frame *frame, int *mode, int *w, int *h);</cproto>
<desc>Retrieves the frame type and dimensions. Returns 0 on success,
or ERR if the frame does not exist.</desc>
</function>

<function name="frame_copy()">
<cproto>frame *frame_copy(frame *frame);</cproto>
<desc>Makes a copy of the given frame.</desc>
</function>

<function name="frame_delete()">
<cproto>void frame_delete(frame *frame);</cproto>
<desc>Deletes the given frame.</desc>
</function>

<function name="frame_set_mask()">
<cproto>void frame_set_mask(frame *frame, unsigned char *data);</cproto>
<desc>Sets the pixel mask for the given frame. This can be useful if
you plan to use one frame both as a tile and as a sprite.</desc>
</function>

<function name="frame_set_mask_from()">
<cproto>void frame_set_mask_from(frame *frame, frame *source);</cproto>
<desc>Sets the pixel mask for the given frame one of two ways,
depending on the source frame. If the source frame has a color
key set, then the pixel mask is generated by non-transparent
pixels. If the source frame has no transparency set, then each
pixel is desaturated and any pixels darker than middle gray are
treated as solid. This routine only accepts RGB-type frames.</desc>
</function>

<function name="frame_slice()">
<cproto>frame *frame_slice(frame *frame, int x, int y, int width, int height);</cproto>
<desc>Copies out a section out of the given RGB frame and returns it
as a new frame.</desc>
</function>

<function name="frame_convert()">
<cproto>frame *frame_convert(frame *frame, int mode, void *auxiliary);</cproto>
<desc>Converts an RGB frame to almost any other frame type. This
routine modifies the frame in-place, so you should make a copy
if you plan to use the original again.</desc>
</function>

<function name="frame_from_disk()">
<cproto>frame *frame_from_disk(char *file, color *key);</cproto>
<desc>Loads and decompresses the given image file into an RGB frame.
<note>Note: This routine is only available if the Brick
Engine was built with SDL_image support.</note></desc>
</function>

<function name="frame_from_buffer()">
<cproto>frame *frame_from_buffer(int len, unsigned char *data, color *);</cproto>
<desc>Loads and decompresses an RGB frame from an image file stored in
the given data buffer. <note>Note: This routine is only
available if the Brick Engine was built with SDL_image
support.</note></desc>
</function>

</section>
<section title="Layers">

<desc>Layers are the basic building block of graphics programming with
the Brick Engine. A layer consists of a sprite list, a tile-
based map, and a string list. Any of these items can be omitted,
and if all three are omitted, the layer is ignored. Each layer
also has a camera position, which determines what part of the
layer (i.e. the layer's sprites and map..more on strings in a
minute) is visible. Strings are a little different, in that
they're always rendered exactly where they're placed, and do not
move when the layer camera is moved. The layers are rendered in
order of creation, and they can be swapped with one another.</desc>

<desc>Each layer can also have a viewport set, which determines the
region of the screen where the layer will actually be drawn.
(This allows for easy split-screen gaming, e.g. create a layer,
set its viewport to the left half of the screen, then copy it
into a new layer and set that layer's viewport to the right side
of the screen. Each layer's camera can then be focused on
different players.)</desc>

<desc>Layers have two attributes which are worth mentioning:
visibility and sorting. Layer visibility doesn't really need
further explanation. The visibility attribute can be set at any
time. Sorting, however, is more complicated. Some games may
require that sprites are rendered in a certain order, e.g. a
sprite that passes in front of another and then behind it, and
sorting is a way to achieve that. When layer sorting is enabled,
all sprites in that layer are sorted by their z-hint attribute
before rendering, and are then rendered in order.</desc>

<function name="layer_count()">
<cproto>int layer_count();</cproto>
<desc>Returns the current number of layers.</desc>
</function>

<function name="layer_add()">
<cproto>int layer_add();</cproto>
<desc>Adds a new layer and returns its ID. When a layer is added, a
sprite list, map, and string list are automatically created.</desc>
</function>

<function name="layer_reorder()">
<cproto>void layer_reorder(int first, int second);</cproto>
<desc>Swaps the first layer with the second.</desc>
</function>

<function name="layer_remove()">
<cproto>void layer_remove(int id);</cproto>
<desc>Removes the specified layer</desc>
</function>

<function name="layer_copy()">
<cproto>int layer_copy(int id);</cproto>
<desc>Makes a copy of the specified layer, assigning its properties
(sprite list, map, etc) to the new layer.</desc>
</function>

<function name="layer_get_sprite_list()">
<cproto>list *layer_get_sprite_list(int id);</cproto>
<desc>Returns the sprite list for the given layer.</desc>
</function>

<function name="layer_get_map()">
<cproto>map *layer_get_map(int id);</cproto>
<desc>Returns the map for the given layer.</desc>
</function>

<function name="layer_get_string_list()">
<cproto>list *layer_get_string_list(int id);</cproto>
<desc>Returns the string list for the given layer.</desc>
</function>

<function name="layer_get_visible()">
<cproto>int layer_get_visible(int id);</cproto>
<desc>Returns a boolean value for the layer visibility setting.</desc>
</function>

<function name="layer_get_sorting()">
<cproto>int layer_get_sorting(int id);</cproto>
<desc>Returns a boolean value for sprite z-hint sorting on the given
layer.</desc>
</function>

<function name="layer_set_sprite_list()">
<cproto>void layer_set_sprite_list(int id, list *list);</cproto>
<desc>Sets the sprite list for the given layer.</desc>
</function>

<function name="layer_set_map()">
<cproto>void layer_set_map(int id, map *map);</cproto>
<desc>Sets the map for the given layer.</desc>
</function>

<function name="layer_set_string_list()">
<cproto>void layer_set_string_list(int id, list *list);</cproto>
<desc>Sets the string list for the given layer.</desc>
</function>

<function name="layer_set_visible()">
<cproto>void layer_set_visible(int id, int mode);</cproto>
<desc>Sets the layer visibility setting to the boolean value specified
in <namedvar>mode</namedvar>.</desc>
</function>

<function name="layer_set_sorting()">
<cproto>void layer_set_sorting(int id, int mode);</cproto>
<desc>Sets the sprite z-hint sorting value setting on the given layer.</desc>
</function>

<function name="layer_get_camera()">
<cproto>int layer_get_camera(int id, int *x, int *y);</cproto>
<desc>Retrieves the camera position on the specified layer. Returns 0
on success, or ERR if the layer ID is invalid.</desc>
</function>

<function name="layer_set_camera()">
<cproto>void layer_set_camera(int id, int x, int y);</cproto>
<desc>Sets the camera position on the specified layer.</desc>
</function>

<function name="layer_adjust_camera()">
<cproto>void layer_adjust_camera(int id, int x, int y);</cproto>
<desc>Adjusts the camera position on the specified layer.</desc>
</function>

<function name="layer_get_view()">
<cproto>int layer_get_view(int id, box *);</cproto>
<desc>Retreives the viewport on the specified layer. Returns 0 on
success, or ERR if the layer ID is invalid.</desc>
</function>

<function name="layer_set_view()">
<cproto>void layer_set_view(int id, box *);</cproto>
<desc>Sets the viewport on the specified layer.</desc>
</function>

</section>
<section title="Maps">

<desc>The tile-based map is an important part of much of 2D game
programming, and the Brick Engine has some useful map
functionality built in. Every display layer gets one map, and
it's always optional whether or not to use the map for any given
layer.</desc>

<desc>A map consists of two things: a set of tiles, and an array of
map data. So, to get started with the tile-based maps, you'll
first create one or more tiles using the tile-handling commands.
You'll then add them to the map's tile index, a fixed-length
array of tiles (there's a compile-time limit that determines the
size of this array, by default limited to 4096 tiles), and set
the tile size as well as the overall map dimensions. Last,
you'll set the map data, either one element at a time or all at
once. Each entry in the map data array is a number that
corresponds to the tile index containing the tile you want to
appear at that position on the map.</desc>

<desc>So, if you have a map that with a width of 3 and a height of 2,
the map data array will consist of six numbers. The first three
numbers indicate which tiles will show on the first row of the
map, and the second three numbers indicate which tiles show on
the second row of the map.</desc>

<desc>If your map data has tile indices that haven't had any tiles
set, then nothing will be rendered (e.g. a hole will appear, and
whatever was underneath will be visible) at that point of the
map.</desc>

<function name="map_create()">
<cproto>map *map_create();</cproto>
<desc>Creates a new map.</desc>
</function>

<function name="map_empty()">
<cproto>void map_empty(map *map);</cproto>
<desc>Empties a map and resets all map attributes, but does not delete
the map itself.</desc>
</function>

<function name="map_delete()">
<cproto>void map_delete(map *map);</cproto>
<desc>Deletes a map.</desc>
</function>

<function name="map_get_size()">
<cproto>int map_get_size(map *map, int *w, int *h);</cproto>
<desc>Stores the size of the map into <namedvar>w</namedvar> and
<namedvar>h</namedvar>. Returns 0 on success, or ERR if the map
does not exist.</desc>
</function>

<function name="map_get_tile_size()">
<cproto>int map_get_tile_size(map *map, int *tw, int *th);</cproto>
<desc>Stores the map's tile size into <namedvar>tw</namedvar> and
<namedvar>th</namedvar>. Returns 0 on success, or ERR if the map
does not exist.</desc>
</function>

<function name="map_get_tile()">
<cproto>int map_get_tile(map *map, int index, tile **tile);</cproto>
<desc>Stores the tile pointer for the given map index into
<namedvar>tile</namedvar>. Returns 0 on success, or ERR if the
map does not exist.</desc>
</function>

<function name="map_set_size()">
<cproto>void map_set_size(map *map, int w, int h);</cproto>
<desc>Sets the overall dimensions for the given map.</desc>
</function>

<function name="map_set_tile_size()">
<cproto>void map_set_tile_size(map *map, int tw, int th);</cproto>
<desc>Sets the tile size for the given map.</desc>
</function>

<function name="map_set_tile()">
<cproto>void map_set_tile(map *map, int index, tile *tile);</cproto>
<desc>Loads the given tile into the map's tile index.</desc>
</function>

<function name="map_set_data()">
<cproto>void map_set_data(map *map, short *data);</cproto>
<desc>Sets the map data for the given map. <namedvar>w</namedvar> and
<namedvar>h</namedvar> are the dimensions of the map. The map
data is of 16-bit words, each word containing the index of the
tile to display.</desc>
</function>

<function name="map_set_single()">
<cproto>void map_set_single(map *map, int x, int y, short data);</cproto>
<desc>Sets a single element in the map data. <namedvar>x</namedvar>
and <namedvar>y</namedvar> are the tile coordinates to be set.
The tile is a 16-bit word containing the index of the tile.</desc>
</function>

<function name="map_animate_tiles()">
<cproto>void map_animate_tiles(map *map);</cproto>
<desc>Animate all tiles on the given map.</desc>
</function>

<function name="map_reset_tiles()">
<cproto>void map_reset_tiles(map *map);</cproto>
<desc>Reset all tile animation on the given map.</desc>
</function>

</section>
<section title="Tiles">

<desc>These routines allow you to create the tiles (and set the
properties of same) that you can then load into your maps.</desc>

<function name="tile_create()">
<cproto>tile *tile_create();</cproto>
<desc>Creates a new tile.</desc>
</function>

<function name="tile_delete()">
<cproto>void tile_delete(tile *tile);</cproto>
<desc>Deletes a tile and frees all of its image data.</desc>
</function>

<function name="tile_get_collides()">
<cproto>int tile_get_collides(tile *tile, int *mode);</cproto>
<desc>Retrieves the collision mode for the specified tile. Returns 0
on success, or ERR if the tile does not exist.</desc>
</function>

<function name="tile_set_collides()">
<cproto>void tile_set_collides(tile *tile, int mode);</cproto>
<desc>Sets the collision mode for the specified tile. The
<namedvar>mode</namedvar> must be one of: COLLISION_OFF (sprite
does not collide), COLLISION_BOX (collision testing by bounding
box), or COLLISION_PIXEL (collision testing by pixel-mask).</desc>
</function>

<function name="tile_get_anim_type()">
<cproto>int tile_get_anim_type(tile *tile, int *type);</cproto>
<desc>Retrieves the animation type for the specified tile. Returns 0
on success, or ERR if the tile does not exist.</desc>
</function>

<function name="tile_set_anim_type()">
<cproto>void tile_set_anim_type(tile *tile, int type);</cproto>
<desc>Sets the animation type for the specified tile. Valid animation
types are: ANIMATE_OFF (do not animate), ANIMATE_FWD (forward
looping animation), ANIMATE_REV (reverse looping animation), and
ANIMATE_PP (ping-pong animation).</desc>
</function>

<function name="tile_add_frame()">
<cproto>int tile_add_frame(tile *tile, frame *frame);</cproto>
<desc>Adds the given frame to the tile. Please note that this does not
make a copy of the frame, so you will likely want to make a copy
of the frame before passing it to this routine (e.g. if you use
that particular frame anywhere else).</desc>
</function>

<function name="tile_add_frame_data()">
<cproto>int tile_add_frame_data(tile *tile, int mode, int width,
    int height, void *data, void *aux);</cproto>
<desc>Loads the given graphics data into the tile. The documentation
for <namedvar>frame_create()</namedvar> has a detailed
description of the arguments, as this is essentially a wrapper
for that routine.</desc>
</function>

<function name="tile_set_pixel_mask()">
<cproto>void tile_set_pixel_mask(tile *tile, int index,
    unsigned char *data);</cproto>
<desc>Sets a pixel-accurate collision mask for the specified frame of
the tile. Any non-zero value in the <namedvar>data</namedvar>
buffer counts as an active pixel.</desc>
</function>

<function name="tile_set_pixel_mask_from()">
<cproto>void tile_set_pixel_mask_from(tile *tile, int index, frame *source);</cproto>
<desc>Sets a pixel-accurate collision mask for the specified frame of
the tile from a source frame. If the source frame has a color
key set, then the opaque pixels represent the collidable
portions of the pixel mask. If the source frame does not have a
color key, then each pixel is desaturated and any pixel lighter
than neutral gray (r, g, b = 128) counts as an active pixel.</desc>
</function>

<function name="tile_animate()">
<cproto>void tile_animate(tile *tile);</cproto>
<desc>Animates the specified tile.</desc>
</function>

<function name="tile_reset()">
<cproto>void tile_reset(tile *tile);</cproto>
<desc>Resets the tile animation for the specified tile.</desc>
</function>

</section>
<section title="Sprites">

<desc>Sprites are movable graphical elements that comprise the basic
building blocks of most games you'll make with the Brick Engine.
They're similar to the idea of hardware sprites that you'll find
in consoles and old computers, but with some very useful
improvements.</desc>

<desc>Each sprite can have an unlimited number of graphics frames
added to it for animation, and each frame can have subframes
that are rendered in series to aid in composition of sprites and
effects. The effects are the other unique thing about Brick
Engine sprites. A given sprite frame (or subframe) isn't just a
block of RGB data, but can be one of a variety of color-
manipulation effects, such as brightness or
saturation/desaturation effects, or pixel-manipulation effects,
such as user-defined convolution kernels. These effects allow
for a wide variety of engaging visuals, like shadows, real-time
reflective mirrors, rippling water effects, heat-blurring of
rocket jets, and so on.</desc>

<desc>Sprites can also have two kinds of collision-detection enabled,
bounding box collision detection (very fast) and pixel-accurate
collision detection (not as fast, but as accurate as you
specify).</desc>

<desc>Brick Engine sprites offer two more seldom-used features that
come in handy for specific situations, z-hinting and motion
control programs. Z-hinting allows sprites to be drawn in a
certain order, e.g. if a sprite passes alternately in front of
and behind a level object. Z-hinting must enabled at for a given
layer, and the z-hint values are otherwise ignored. Motion
control programs are little scripts attached to sprites that
allow for some autonomous behavior, and have their own section
in this document, which you ought to consult to learn more.</desc>

<function name="sprite_create()">
<cproto>sprite *sprite_create();</cproto>
<desc>Creates a new sprite.</desc>
</function>

<function name="sprite_copy()">
<cproto>sprite *sprite_copy(sprite *sprite);</cproto>
<desc>Makes a copy of the given sprite.</desc>
</function>

<function name="sprite_delete()">
<cproto>void sprite_delete(sprite *sprite);</cproto>
<desc>Deletes the given sprite and frees all of the frame data.</desc>
</function>

<function name="sprite_set_frame()">
<cproto>void sprite_set_frame(sprite *sprite, int frame);</cproto>
<desc>Selects a sprite frame for display.</desc>
</function>

<function name="sprite_get_frame()">
<cproto>int sprite_get_frame(sprite *sprite, int *frame);</cproto>
<desc>Stores the frame that is currently selected in
<namedvar>frame</namedvar>. Returns 0 on success, or ERR if
given an invalid sprite.</desc>
</function>

<function name="sprite_set_z_hint()">
<cproto>void sprite_get_z_hint(sprite *sprite, int z_hint);</cproto>
<desc>Sets the sprite's z-hint. When layer sorting is enabled, then
sprites are sorted by z-hint before being drawn. When layer
sorting is not enabled, the sprite's z-hint has no effect.</desc>
</function>
<function name="sprite_get_z_hint()">

<cproto>int sprite_get_z_hint(sprite *sprite, int *z_hint);</cproto>
<desc>Stores the sprite's z-hint into <namedvar>z_hint</namedvar>.
Returns 0 on success, or ERR if given an invalid sprite.</desc>
</function>

<function name="sprite_set_collides()">
<cproto>void sprite_set_collides(sprite *sprite, int mode);</cproto>
<desc>Sets the sprite's collision mode. The <namedvar>mode</namedvar>
must be one of: COLLISION_OFF (sprite does not collide),
COLLISION_BOX (collision testing by bounding box), or
COLLISION_PIXEL (collision testing by pixel-accurate mask).</desc>
</function>

<function name="sprite_get_collides()">
<cproto>int sprite_get_collides(sprite *sprite, int *mode);</cproto>
<desc>Stores the sprite's collision mode into
<namedvar>mode</namedvar>. Returns 0 on success, or ERR if given
an invalid sprite.</desc>
</function>

<function name="sprite_set_bounding_box()">
<cproto>void sprite_set_bounding_box(sprite *sprite, int frame, box *box);</cproto>
<desc>Sets the bounding box for the specified frame of the sprite.</desc>
</function>

<function name="sprite_set_pixel_mask()">
<cproto>void sprite_set_pixel_mask(sprite *sprite, int frame, unsigned char *data);</cproto>
<desc>Sets the pixel-accurate collision mask for the specified frame
of the sprite. Any non-zero value in the
<namedvar>data</namedvar> buffer counts as an active pixel.</desc>
</function>

<function name="sprite_set_pixel_mask_from()">
<cproto>void sprite_set_pixel_mask_from(sprite *sprite, int frame, frame *source);</cproto>
<desc>Sets the pixel-accurate collision mask for the specified frame
of the sprite from a source frame. If the source frame has a
color key set, then the opaque pixels in the frame represent the
collidable portions of the pixel mask. If the source frame does
not have a color key, then the source frame is desaturated and
any pixel lighter than neutral gray (r, g, b = 128) counts as an
active, collidable pixel.</desc>
</function>

<function name="sprite_set_position()">
<cproto>void sprite_set_position(sprite *sprite, int x, int y);</cproto>
<desc>Sets the position of the sprite.</desc>
</function>

<function name="sprite_get_position()">
<cproto>int sprite_get_position(sprite *sprite, int *x, int *y);</cproto>
<desc>Stores the position of the sprite into <namedvar>x</namedvar>
and <namedvar>y</namedvar>. Returns 0 on success, or ERR if
given an invalid sprite.</desc>
</function>

<function name="sprite_set_velocity()">
<cproto>void sprite_set_velocity(sprite *sprite, int x, int y);</cproto>
<desc>Sets the velocity of the sprite. Note that this doesn't actually
move the sprite or cause the sprite to be moved. This is only
used in setting up your proposed sprite motions for collision
detection, e.g. so that you can test how far your sprite may
move before it hits a wall or another sprite.</desc>
</function>

<function name="sprite_get_velocity()">
<cproto>int sprite_get_velocity(sprite *sprite, int *x, int *y);</cproto>
<desc>Stores the velocity of the sprite into <namedvar>x</namedvar>
and <namedvar>y</namedvar>. Returns 0 on success, or ERR if
given an invalid sprite.</desc>
</function>

<function name="sprite_add_frame()">
<cproto>int sprite_add_frame(sprite *sprite, frame *frame);</cproto>
<desc>Adds the given frame to the sprite. Please note that this does
not make a copy of the frame, so be aware that you will probably
want to make a copy of your graphics frame before passing it to
this routine.</desc>
</function>

<function name="sprite_add_frame_data()">
<cproto>int sprite_add_frame_data(sprite *sprite, int mode, int w, int h,
    void *data, void *auxiliary);</cproto>
<desc>Loads a graphics frame into the given sprite. The documentation
for <namedvar>frame_create()</namedvar> has a detailed
description of the arguments. This is essentially a wrapper for
that routine.</desc>
</function>

<function name="sprite_add_subframe()">
<cproto>int sprite_add_subframe(sprite *sprite, int index, frame *frame);</cproto>
<desc>Adds the frame to the sprite as a subframe on the given frame
index. Subframes are rendered in reverse order, i.e. the last-
added subframe is rendered first. This allows for easy
compositing of sprite frames together (e.g. a shadow, a lighting
effect, etc) into a single sprite. Please note that this does
not make a copy of the frame, however, so you'll probably want
to make a copy of the frame before passing it into this routine.</desc>
</function>

<function name="sprite_load_program()">
<cproto>int sprite_load_program(sprite *sprite, char *program);</cproto>
<desc>This routine loads the given motion control program into the
sprite. Please see the section on Motion Control Programs for a
detailed description of how to write these programs.</desc>
</function>

</section>
<section title="Strings">

<desc>Strings are what you'll use to display blocks of text onscreen,
such as in character dialogue or as part of a heads-up display.
These are the routines used to create and manipulate strings.
After creating and configuring your text strings, you'll need to
add them to a layer's string list in order for them to be
displayed. <note>Note that strings are positioned
absolutely on the display canvas and do not move when the layer
camera moves.</note></desc>

<function name="string_create()">
<cproto>string *string_create();</cproto>
<desc>Creates a new string.</desc>
</function>

<function name="string_delete()">
<cproto>void string_delete(string *string);</cproto>
<desc>Deletes the given string.</desc>
</function>

<function name="string_set_font()">
<cproto>void string_set_font(string *string, char *font);</cproto>
<desc>Sets the font for the given string. If an unknown font name is
assigned to a string, the string will not be displayed.</desc>
</function>

<function name="string_set_position()">
<cproto>void string_set_position(string *string, int x, int y);</cproto>
<desc>Sets the position for the given string.</desc>
</function>

<function name="string_set_text()">
<cproto>void string_set_text(string *string, char *text);</cproto>
<desc>Sets the text contents of the given string.</desc>
</function>

</section>
</section>
<section title="The Motion Control Program System">

<section title="The Language">

<desc>Motion control programs are very short programs, written in a
custom language, that give sprites some simple autonomy, i.e.
without having to run callbacks in the main game loop. They're
especially useful when the programmer is using a scripting
language but still desires to animate great numbers of sprites.,
because they can eliminate the need to fire potentially-heavy
script callbacks for sprite motion.</desc><desc>
Motion control programs can also be used to generate simple
particle systems, environmental effects, and the like. Note that
motion control programs aren't intended to be a generic
replacement for sprite movement. For more detailed information,
please see the in-depth guide at the [[motion control programs]]
page.</desc>

<desc>The language consists of the following instructions.
Instructions and their arguments appear one per line. Whitespace
and empty lines are ignored.</desc>

<cproto>
set var, var/immediate  - store the right-side value in the left-side
                          named var
add var, var/immediate  - add the right-side value to the left-side
                          named var
stc var, var/immediate  - stochastic alter the left-side var with a
                          range of -(var/imm)..var/imm
trk var, id             - copy over the left-side named var contents
                          from another sprite
avg var, id             - average the left-side named var contents with
                          those of another sprite
beq var, var/immediate  - break (immediately exit the program) if equal
bne var, var/immediate  - break if not equal
blt var, var/immediate  - break if less than
bgt var, var/immediate  - break if greater than
bmp id                  - break if there is a collision with the given
                          map
bnm id                  - break if there is a not a collision with the
                          given map
bst var/immediate       - stochastic break, i.e. exit if random value
                          between zero and imm is zero
copy id                 - make a copy of the sprite and replace the
                          current sprite with the copy for the remain-
                          der of the program
ladd id                 - add the sprite to the given list
lrem id                 - remove the sprite from the given list
del                     - delete the sprite
xchgp ptr               - exchange the sprite's motion control program
                          with another sprite's program
sound id                - play the sound
eoc                     - end of code</cproto>
<desc>The <namedvar>var</namedvar> is a named variable, one of the
following: <namedvar>xpos</namedvar>, <namedvar>ypos</namedvar>,
<namedvar>xvel</namedvar>, <namedvar>yvel</namedvar>,
<namedvar>frame</namedvar>, <namedvar>tick</namedvar>.
<namedvar>xpos</namedvar> and <namedvar>ypos</namedvar> refer to
the sprite's position, and <namedvar>xvel</namedvar> and
<namedvar>yvel</namedvar> refer to the sprite's velocity.
Immediate values are integers, and <namedvar>id</namedvar>
values specify a list, sprite, map, or sound. Argument order
matches Intel-style assembly language syntax, i.e. instructions
that set or change a variable have the destination given first
(<note>set xpos, 4</note> can be read as
<note>xpos = 4</note>)</desc><desc>
Every sprite also has its own internal tick counter, and this
increments every time the sprite's motion-control program is
run.</desc>

</section>
<section title="Running motion control programs">

<desc>These routines execute the motion control programs for a sprite
or for a list of sprites.</desc>

<function name="motion_exec_single()">
<cproto>int motion_exec_single(sprite *sprite);</cproto>
<desc>Executes the motion control program for the given sprite.
Returns 0 on success, or an error code on failure.</desc>
</function>

<function name="motion_exec_list()">
<cproto>int motion_exec_list(list *list);</cproto>
<desc>Executes the motion control program for every sprite in the
given list. Returns 0 on success, or an error code if any motion
control program fails to execute.</desc>
</function>

</section>
</section>
<section title="Introspection and Collision Detection">

<section title="Inspection">

<desc>It's often the case that you'll need to have a sprite query its
surroundings or check to see if anything else is nearby. If you
wanted to have a sprite avoid a patch of water, for example, you
could use the introspection routines to read the nearby tiles
and have the sprite govern itself accordingly. These
introspection routines allow you to do that, along with a few
other methods of examining the environment.</desc>

<function name="inspect_adjacent_tiles()">
<cproto>void inspect_adjacent_tiles(map *map, sprite *spr, int dir,
    map_fragment *res);</cproto>
<desc>Returns a buffer of tiles adjacent to the sprite on the
specified map. The direction must be one of
<namedvar>INSPECT_NW</namedvar>, <namedvar>INSPECT_N</namedvar>,
<namedvar>INSPECT_NE</namedvar>, <namedvar>INSPECT_E</namedvar>,
<namedvar>INSPECT_SE</namedvar>, <namedvar>INSPECT_S</namedvar>,
<namedvar>INSPECT_SW</namedvar>, <namedvar>INSPECT_W</namedvar>.
If the sprite is using bounding box collision, the buffer of
tiles is determined by the edge of the bounding box. If pixel-
accurate collision is enabled, the bounding edges of the pixel
mask are used.</desc>
</function>

<function name="inspect_obscured_tiles()">
<cproto>void inspect_obscured_tiles(map *map, sprite *spr, map_fragment *res);</cproto>
<desc>Returns a buffer of tiles obscured by the sprite on the
specified map. If the sprite is using bounding box collision,
the tiles are determined by the edge of the bounding box. If
pixel-accurate collision is enabled, the bounding edges of the
pixel mask are used.</desc>
</function>

<function name="inspect_line_of_sight()">
<cproto>int inspect_line_of_sight(map *map, sprite *spr, int xofs, int yofs,
    int dist, sprite *target);</cproto>
<desc>Performs a line-of-sight test to determine visibility from the
originating sprite to the target sprite within the given map.
The <namedvar>xofs</namedvar> and <namedvar>yofs</namedvar>
offsets determine the point, relative to the sprite's upper left
corner, from which the visibility test is performed. These
offsets can be negative, performing the visibility test from a
point outside the originating sprite's frame. The
<namedvar>dist</namedvar> value is the maximum range for the
test.</desc>

<desc>The originating sprite does not need to have collision detection
enabled, but the target sprite must have collision detection
enabled. If the target sprite has bounding-box collision
enabled, the four corners of the bounding box are checked for
visibility from the originating sprite. If the target sprite has
pixel-accurate collision enabled, the visibility test is
performed on the four corners of the pixel mask's bounding
edges.</desc>
</function>

<function name="inspect_in_frame()">
<cproto>list *inspect_in_frame(list *list, box *range);</cproto>
<desc>Returns a list of sprites that fall within the given rectangle.</desc>
</function>

<function name="inspect_near_point()">
<cproto>sprite *inspect_near_point(list *list, int x, int y, int distance);</cproto>
<desc>Returns a list of sprites near the given point.</desc>
</function>

</section>
<section title="Collisions">

<desc>These routines detect collisions among sprites, and between
sprites and maps.</desc>

<function name="collision_with_map()">
<cproto>void collision_with_map(sprite *sprite, map *map, int slip,
    map_collision *res);</cproto>
<desc>Checks the given sprite for collision against the given map. The
optional slip argument indicates that, when a collision occurs,
the sprite will be adjusted by the given number of one-pixel
increments to continue motion. <note>Note: The slip
factor allows sprites to travel near the corners of maps without
stopping on all single-pixel collisions.</note></desc>

<desc>The result is stored <namedvar>res</namedvar>.
The <namedvar>res.mode</namedvar> value will be
<namedvar>COLLISION_ATSTART</namedvar> to indicate that the sprite
and map were colliding before motion began,
<namedvar>COLLISION_NEVER</namedvar> to indicate that
no collision has occurred, or
<namedvar>COLLISION_INMOTION</namedvar> to indicate that
collision occurred during motion. The pixel distance before
the sprite hits the map is stored in
<namedvar>res.stop</namedvar> and the distance that the sprite
may travel after being adjusted by the given
<namedvar>slip</namedvar> value is stored in
<namedvar>res.go</namedvar>.</desc>
</function>

<function name="collision_with_sprites()">
<cproto>int collision_with_sprites(sprite *sprite, list *sprite_list,
    int limit, sprite_collision res[]);</cproto>
<desc>Tests the given sprite for collisions with all collidable
members of the given sprite list. Only
<namedvar>limit</namedvar> collisions will be returned, and
<namedvar>res</namedvar> must be large enough to hold this
number of collisions. The <namedvar>res.mode</namedvar> value
will be <namedvar>COLLISION_ATSTART</namedvar> to indicate that
the sprite and map were colliding before motion began,
<namedvar>COLLISION_NEVER</namedvar> to indicate that no
collision has occurred, or
<namedvar>COLLISION_INMOTION</namedvar> to indicate that
collision occurred during motion. The pixel distance before the
sprite hits the target is stored in
<namedvar>res.dist</namedvar> and the direction in which the
collision occurred is stored in <namedvar>res.hit</namedvar>.</desc>
</function>

</section>
</section>
<section title="Utilities">

<section title="Timing">

<desc>A routine useful for setting up a basic delay loop and holding a
steady framerate.</desc>

<function name="delay()">
<cproto>int delay(int fps);</cproto>
<desc>If the time between calls to <namedvar>delay()</namedvar> is
less than necessary (i.e. the game would otherwise run too fast)
to maintain the given <namedvar>fps</namedvar> rate, then the
routine will delay until enough time has passed. if the game is
running too slowly to maintain the requested
<namedvar>fps</namedvar> rate, <namedvar>delay()</namedvar> will
return the number of frames that must be skipped to maintain
speed.</desc>
</function>

</section>
<section title="Scheduled events">

<desc>The Brick Engine includes a simple event scheduler. Events are
functions that take a single void * argument and return nothing.
They run in their own thread, and can be schedule to run once,
several times, or to be repeated indefinitely. They can also be
paused, halted, or temporarily skipped.</desc>

<function name="event_add()">
<cproto>int event_add(int delay, int count, event ev, void *data);</cproto>
<desc>Schedules an event to run after <namedvar>delay</namedvar>
milliseconds. The <namedvar>count</namedvar> determines how many
times the event is run. If <namedvar>count</namedvar> is
negative, the event will repeat indefinitely.
<namedvar>ev</namedvar> is a pointer to the function to run.
When <namedvar>ev</namedvar> is called,
<namedvar>data</namedvar> is passed to it. The
<namedvar>data</namedvar> argument can, of course, be null. The
event ID is returned, so that messages can be passed to the
event, e.g. to pause or cancel its execution.</desc>
</function>

<function name="event_message()">
<cproto>void event_message(int id, int msg);</cproto>
<desc>Sends a message to the given event. If the message is EVENT_GO,
the event will run as normal. If the message is EVENT_STOP, the
event will be cancelled. If the message is EVENT_PAUSE, event
execution is paused until the event is resumed (with EVENT_GO)
or halted (with EVENT_STOP). If the message is EVENT_SKIP1, the
event will not execute the next time it's scheduled to, but will
execute each subsequent time and its execution count will be
decremented as though it ran (e.g. if it's scheduled to run 10
times, then after being sent EVENT_SKIP1 once, it will run 9
times total).</desc>
</function>

</section>
</section>
</section>
